# 面向对象
##概述

对象：泛指一切事物，每种事物都具备自己的“事物”和"行为"

面向对象思想：在计算机程序设计过程中，参照现实中的事务，将事务的属性特征、行为特征
抽象出来，描述成计算机事件的设计思想，它区别于面向过程思想，强调的是通过调用对象的
行为来实现功能，而不用自己一步步的去操作;

举例：

- 面向过程：把衣服脱下来-->找一个盆-->放点洗衣粉-->加点水-->浸泡10分钟-->揉一揉-->清洗衣服-->拧干-->晾
起来
- 面向对象：把衣服脱下来-->打开全自动洗衣机-->扔衣服-->按钮-->晾起来

区别:
- 面向过程：强调步骤。
- 面向对象：强调对象，这里的对象就是洗衣机。

特点：
面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。
面向对象的语言中，包含了三大基本特征，即封装、继承和多态。

## 类与对象

类：是一组相关“属性”和"行为"的集合，可以看成是一类事物的模板，使用事物的属性和行为特征来描述该类事物

属性：该事物的状态信息
行为：该事物能够做什么

对象：是一类事物的具体体现，对象是类的一个实例，必然具备该类事物的属性和行为

类与对象的关系：
- 类是一类对象的描述，是抽象的
- 对象是一类事物的实例，是具体的
- 类是对象的模板，对象是类的实体

## 类的定义

成员变量：对应事物的属性
成员方法：对应事物的行为

### 定义格式
		
		public class ClassName {
		  // 成员变量
		  // 成员方法
		}

- 定义类：就是定义类的成员，包括"成员变量"和"成员方法"
- 成员变量：和定义变量一样，定义在类中、方法外
- 成员方法：定义在类中的方法

### 对象的使用

创建对象

	类名 对象名 = new 类名();

使用对象访问类中的成员

	对象名.成员变量;
	对象名.成员方法();
	
### 成员变量的默认值

- 整数(byte、short、ing、long)  0
- 浮点数（float，double） 0.0
- 字符（char） '\u0000'
- 布尔（boolean） false
- 引用类型 数组，类，接口 null

### 成员变量与局部变量的区别

变量根据定义位置不同，给变量起了不同的名字

![](img/局部变量与成员变量.png)

- 在类中的位置不同 重点
	- 成员变量：类中，方法外
	- 局部变量：方法中或者方法声明上(形式参数)
- 作用范围不一样 重点
	+ 成员变量：类中
	+ 局部变量：方法中
- 初始化值的不同 重点
	+ 成员变量：有默认值
	+ 局部变量：没有默认值。必须先定义，赋值，最后使用
- 在内存中的位置不同 了解
	+ 成员变量：堆内存
	+ 局部变量：栈内存
- 生命周期不同 了解
	+ 成员变量：随着对象的创建而存在，随着对象的消失而消失
	+ 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失

## 对象的内存图

1.一个对象，调用一个方法内存图

![](img/01-只有一个对象的内存图.png)

>通过上图，我们可以理解，在栈内存中运行的方法，遵循"先进后出，后进先出"的原则。变量p指向堆内存中
的空间，寻找方法信息，去执行该方法。
但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存
了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。

2.两个对象，调用同一方法内存图

![](img/02-两个对象使用同一个方法的内存图.png)

>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息
只保存一份，节约内存空间。

3.两个引用，指向同一对象

![](img/03-两个引用指向同一个对象的内存图.png)

# 封装

## 概述
面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。
封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的
方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。

## 原则
将"属性"隐藏起来，若需要访问某个属性，"提供公共方法"对其访问

## 封装的步骤
- 使用private关键字来修饰成员变量
- 对需要访问的成员变量，提供对应的getting()和setting()方法

## 封装的操作--private关键字
- private的含义
 + private是一个权限修饰符，代表最小权限
 + 可以修饰成员变量和成员方法
 + 被private修饰后的成员变量和成员方法，只有本类才能访问
 
- private的使用格式
	
	
	private 数据类型 变量名;

## 封装优化1--this关键字

- 含义：this代表所在类的当前对象的引用(地址值)，即对象自己的引用
>方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。

- 使用格式
	
			
	this.成员变量名;
> ：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写

## 封装优化2--构造函数

当一个对象被创建时，构造方法用来初始化该对象，给对象的成员变量初始化

>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，
 一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。

- 定义格式：
	
	
	修饰符 构造方法名(参数列表) {
	   // 方法体
	}

构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用
构造方法后，

- 注意事项：
	+ 如果你不提供构造方法，系统会给出无参构造方法
	+ 如果你提供了构造方法，系统将不再提供无参数构造方法
	+ 构造方法时可以重载的，既可以定义参数，也可以不定义参数

## JavaBean
JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，该类的设计必须包含：

- 要求类必须是具体的和公共的
- 类属性私有化
- 具有无参数的构造方法
- 提供用来操作成员变量的 set 和 get 方法。
- 实现序列化接口并提供序列化版本号

具体JavaBean的格式
	
	public class ClassName implements Serializable {
		  // 序列化版本号serialVersionUID
		  // 私有成员变量
		  // 无参构造方法【必须】
		  // 有参构造方法【建议】
		  // getXxx()
		  // setXxx()
		  // 重写toString()【推荐】
		  // 重写equals()与hashCode()【推荐】
	}

# 继承
## 概述

思想：多个类存在'相同'的属性和行为的时候，将这些内容抽取到单独的一个类中，那么多个类无需再定义这些
属性和行为，只要`extends`这个类即可

继承描述的是事物之间的所属关系，这种关系称为`is-a`，通过继承可以使多种事物之间形成一种关系体系;

通常被继承类称为`超类SupClass`，继承的类称为`基类SubClass`(子类)

![](img/01-继承的基本概念.png)

![](img/04-Java继承的三个特点.png)

## 定义

继承：就是子类继承超类的`属性`和`行为`，使得子类对象具有与父类相同的属性、相同的`行为`，子类
可以直接访问超类的`非私有`的属性和行为

继承的好处：
- 提供代码的`复用性`
- 类与类之间产生了关系，是`多态`的前提

## 格式
通过`extends`关键字，可以声明一个子类继承另外一个超类，定义格式：
	
	class 超类名 /* extends Object */ {
	  // 属性与方法
	}
	
	class 子类名 extends 超类 {
	  // 属性与方法
	}

## 继承后的特点--成员变量

- 成员变量不重名
	如果子类超类中出现`不重名`的成员变量，此时访问没有影响的
	
- 成员变量重名
	如果子类中出现的`重名`的成员变量，这时访问是有影响的
	
	子类父出现了同名的成员变量的时候，在子类中需要访问父类中非私有的成员变量的时候，需要使用`super`关键字
	修饰父类成员变量，类似于之前的`this`关键字
	
		super.超类成员变量名;

>超类中的成员变量是非私有的，子类中可以直接访问。若超类中的成员变量私有了，子类是不能直接访问的。
通常编码时，我们遵循封装的原则，使用private修饰成员变量，可以在父类中提供公共的getting()方法和setting()方法。

## 继承后的特点--成员方法

- 成员变量不重名
	+ 如果子类超类中出现`不重名`的成员变量，这时调用是没有影响的，
	
	+ 如果子类超类中出现`重名`的成员变量时，对象调用成员变量(非私有)时，会先在子类中查找有没有对应的成员变量，若子类中存在就会执行子类中的成员变量，若子类中不存在就会调用父类中相应的成员变量

- 成员方法重名--重写(Override)
	+ 如果子类中出现了`不重名`的成员方法，这时调用是没有影响的
	
	+ 如果子类中出现了`重名`的成员方法，这时访问的是一种特殊的情况，叫做方法重写(Override)

方法重写：子类中出现与超类中一样的方法时(包括返回值类型、方法名、参数列表相同)，会出现覆盖效果，
这个过程称为重写或复写；即`声明不变，重新实现`

![](img/02-方法覆盖重写的应用场景.png)

>重写的应用思想：子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强
>注意事项：
> 1) 子类方法覆盖超类方法，必须要保证`权限`大于或等于超类权限 
> 2) 子类方法覆盖`超类方法`，`返回值`、`函数名`、`参数列表`一模一样

- 继承后的特点--构造方法
	+ 构造方法必须与类名一致，所以子类是无法继承超类的构造方法的
  + 构造的方法的作用是初始化成员变量，所以子类的初始化过程中，必须`先执行`超类的初始化动作，
   子类的构造默认有一个`super()`表示调用超类的构造方法，超类成员变量初始化后，才可以给子类使用

## 父类空间优先于子类对象产生

在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空
间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构
造方法调用时，一定先调用父类的构造方法。理解图解如下：

![](img/超类构造器优先于子类调用.png)

## 继承的特点

1.Java只支持单继承，不支持多继承
2.Java支持多层继承(抽象继承体系)
>顶层超类是Object类，所有的类默认继承Objcet作为超类

3.子类和超类时一种相对的概念
	

# super与this关键字

## 含义
- super：代表着超类的`存储空间标识`(对超类的引用)
- this：代表着`当前对象的引用`(谁调用就代表谁)

## super和this的用法

1.访问成员
	
	this.成员变量;    // 本类的
	super.成员变量;   // 超类的 
	
	this.成员方法名()  // 本类的
	this.成员方法名()  // 超类的

2.访问构造方法

	this(...)  // 本类的构造方法
	super(...) // 超类的构造方法

![](img/03-super与this的内存图.png)

>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。
 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。

# 抽象类
## 概述

父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有
意义，而方法主体则没有存在的意义了。我们把`没有方法主体`的方法称为`抽象方法`。Java语法规定，包含抽象方法
的类就是抽象类。

![](img/05-抽象的概念.png)

## 定义
- 抽象方法：没有方法体的方法
- 抽象类：包含抽象方法的类

## 抽象关键字abstract使用格式

1.抽象方法

使用`abstract`关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体；

	修饰符 abstract 返回值类型 方法名(参数列表);

2.抽象类

使用一个类包含抽象方法，那么该类必须是抽象类

	abstract class 类名字 {
	
	}
	
## 抽象类的使用

继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。
最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。

此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做`实现方法`。

## 注意事项

1.抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。
>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。

2.抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。

3.抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

4.抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。
>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。

# 接口
## 概述
接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造函数和成员方法，
那么接口的内部主要是`封装了方法`，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）

![](img/01-生活中接口的举例.png)

## 定义

接口的定义，它与定义类的方式相似，使用`interface`关键字，它也会被编译成.class文件，但一定要明确它`不是类`，而是一种另外一种`引用数据类型`

>Java的引用的数据类型：数组、类、接口

接口的使用，它不能创建对象，但是可以被`实现implements`(类似于被继承)。一个实现接口的类（可以看做
是接口的子类）需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。

- 定义格式
	
		public interface 接口名称 {
		  // 常量属性
			// 抽象方法
			// 默认方法(JDK1.8)
			// 静态方法(JDK1.8)
			// 私有方法(JDK1.9)
		}

	+ 含有`抽象`方法：抽象方法：使用 abstract 关键字修饰，可以省略，没有方法体。该方法供子类实现使用；
		
			public interface InterFaceName {
				public abstract void method();
			}
	
	+ 含有`默认`方法和`静态`方法
	
		默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。
		
        静态方法：使用 static 修饰，供接口直接调用。
			
			public interface InterFacaName {
			  public default void method() {
        // 执行语句
        }
        public static void method2() {
        // 执行语句
        }
			}
	
	+ 含有`私有`方法和`私有静态`方法
		
		私有方法：使用 private 修饰，供接口中的默认方法或者静态方法调用。
			
			public interface InterFaceName {
            private void method() {
            // 执行语句
			  }
			}

## 基本的实现

类与接口的关系为实现关系，即`类实现了接口`，该类可以称为类的`实现类`，实现的动作与继承相仿，只是关键字不一样
实现关键字使用`implements`关键字

非抽象子类必须实现接口：
	1.必须重写接口中的所有抽象方法
	2.继承了接口的默认方法，即可以直接调用，也可以重写

实现格式：

	class 类名 implements 接口名 {
	  // 重写接口中抽象方法【必须】
	  // 重写接口中默认方法【可选】
	}

## 接口的多实现

之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接
口的`多实现`。并且，一个类能继承一个父类，同时实现多个接口。

实现格式：

	class 类名 [extends 超类名] implements 接口名1, 接口名2, 接口名3... {
	  // 重写接口中抽象方法【必须】
      // 重写接口中默认方法【不重名时可选】
	}

> 多实现时，如果有多个抽象方法时，实现类必须重写所有抽象方法，如果抽象方法有重名的，只需要重写一次。

## 优先级问题

当一个类，既继承一个父类，又实现若干个接口时，超类中的成员方法与接口中的默认方法重名，
子类就近选择执行父类的成员方法。

## 接口的多继承

一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用`extends`关键字，子接口继
承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次。

>子接口重写默认方法时，default关键字可以保留。
>子类重写默认方法时，default关键字不可以保留。

## 其他成员的特点：

- 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。
- 接口中，没有构造方法，不能创建对象。
- 接口中，没有静态代码块。

# 多态

## 概述
多态是继封装、继承之后面向对象的第三大特征；

多态：同一行为，通过不同的事物，可以体现出来的不同的形态。多态描述的就是这样的状态

![](img/03-多态的概述.png)

## 多态的体现

格式体现：
	
	超类类型 变量名 = new 子类对象;
	变量名.方法名();

>超类类型：指子类对象继承的超类类型，或者实现的超接口类型。

![](img/04-使用多态的好处.png)

## 多态的动作

- 编译时多态：当使用多态方式调用`重载`方法时，首先检查是否有对应的参数列表的方法，如果没有，则编译错误；
如果有，执行的是子类重载后方法。

- 运行时多态：当使用多态方式调用`重写`方法时，首先检查超类中是否有该方法，如果没有，则编译错误；
如果有，执行的是子类重写后方法。

## 引用类型转换

多态的转型分为`向上转型`和`向下转型`

- 向上转型：多态本身是子类类型向超类型向上转换，这个过程是默认的，当超类引用指向一个子类时，便是向上转型


	超类类型 变量名 = new 子类类型();

- 向下转型：超类类型向子类类型向下转换的过程，这个过程是强制的，一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。

	
	子类类型 变量名 = (子类类型)超类变量名;

![](img/05-对象的上下转型.png)

>为什么要转型：
当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥
有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子
类特有的方法，必须做向下转型。
(所以目标就是为了运行子类的特有方法！)
(所以目标就是为了运行子类的特有方法！)

## instanceof数据类型判断关键字

转型的异常：

在向下转型时，会出现`ClassCastException`类型转换异常，这是因为没有正确的使用超类类型进行强制转换；

为了避免出现`ClassCastException`类型转换异常，Java提供了`instanceof`关键字来给引用变量做类型的校验

	if(变量名 instanceof 数据类型) {
	  // 如果变量属于该数据类型，返回true
    // 如果变量不属于该数据类型，返回false
	}

所以，一般转换前都建议做一次判断！

# static 关键字

## 概述

关于`static`关键字的使用，它可以用来修饰成员变量和成员方法，被修饰的成员`属于类`的，而不是
单单是属于某个对象的，也就是说，既然属于类，就可以不靠创建对象来调用了;

## 类变量
当`static`修饰成员变量时，该变量称为`类变量`，该类的每个对象都`共享`同一类变量的值，任何对象都可以更改
该类型变量的值，但也可以在不创建该类的对象的情况下对变量进行操作

- 类对象：使用static关键字修饰的成员变量

定义格式：

	static 数据类型 变量名;

![](img/02-静态static关键字概述.png)

## 静态方法
当`static`修饰成员变量时，该方法称为`类方法`，静态方法在声明中有`static`，建议使用类名来调用。而不需要
创建类的对象，调用方式非常简单；

类方法：使用static关键字修饰的成员变量，习惯称为`静态方法` 

定义格式：

	修饰符 static 返回值类型 方法名(参数列表) {
		// 执行语句
	}
	
静态方法调用的注意事项：
- 静态方法可以`直接访问`类变量和静态方法
- 静态方法`不能直接访问`普通成员变量或成员方法，反之，成员方法可以直接访问类变量或静态方法
- 静态方法中，不能直接使用`this`关键字

调用格式：
被static修饰的成员可以并且建议通过`类名直接访问`。虽然也可以通过对象名访问静态成员，原因即多个对象均属
于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。

调用格式：
	
	// 访问类变量
	类名.类变量名;
	// 调用静态方法
	类名.静态方法名(参数);
	
静态原理图解：

![](img/03-静态的内存图.png)

## 静态代码块

- 静态代码块：定义在成员位置，使用static修饰的代码块{}
 + 位置：类中方法外
 + 执行：随着类的加载而执行并且执行一次，优先于main()方法和构造方法的执行
 
- 定义格式：
	
		public class ClassName {
		    staic {
		    // 执行语句
		    }
		}

- 作用：给类变量进行初始化赋值！

>static关键字的思想:static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况
下，去调用方法

# final关键字
##概述
在继承体系中，如果不对超类内容进行一定的限制，那么子类就可以以在超类的基础上改写父类内容；
为了避免这种随意改写的情况，Java提供了 final 关键字，用于修饰不可改变内容；

- final 不可改变。可以用于修饰类、方法和变量。
	+ 类：被修饰的类，不能被继承
	+ 方法：被修饰的方法，不能被重写
	+ 变量：被修饰的变量，不能被重新赋值

>被final修饰的常量名称，一般都有书写规范，所有字母都大写。

## 使用方式

作修饰符用法

	权限修饰符 final class 类名 {   // 该类不能再被继承
	  权限修饰符 final 返回值类型 方法名(参数列表) {   // 该方法不能再被重写
	  }
	}

- 修饰变量
	
	+ 局部变量--基本类型
	
	  基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改
	
	+ 局部变量--引用类型
	
	  引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改

	+ 成员变量
	
	  成员变量涉及到初始化的问题，初始化方式有两种，只能二选一：显示初始化(定义变量时直接赋值)、构造器方法初始化(定义变量在构造器中初始化)
	
# 权限管理关键字
##概述

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限

- public：公共的。
- protected：受保护的
- default：默认的
- private：私有的
 
## 不同权限的访问能力 

![](img/权限修饰符.png)

# 内部类
##概述

内部类：将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类

成员内部类 ：定义在类中方法外的类

定义格式：
	
	class 外部类 {
      class 内部类{
      }
    }

访问特点
- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类的成员，必须要建立内部类的对象。

创建内部类对象格式：
	
	外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；
	
>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Person$Heart.class

## 匿名内部类
匿名内部类 ：是内部类的简化写法。它的本质是一个`带具体实现的` `父类或者父接口的` `匿名的` 子类对象。
开发中，最常用到的内部类就是匿名内部类了。以接口举例，当你使用一个接口时，似乎得做如下几步操作，

1.定义子类

2.重写接口中的方法

3.创建子类对象

4.调用重写后的方法

匿名内部类就是做这样的快捷方式。

前提：匿名内部类必须继承一个父类或者实现一个父接口。

格式：

	new 父类名或者接口名(){
	  // 方法重写
	  @Override
	  public void method() {
	    // 执行语句
	  }
	};
